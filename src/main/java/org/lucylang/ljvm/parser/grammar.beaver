%package "org.lucylang.ljvm.parser";

%import "org.lucylang.ljvm.node.*";

%class "Parser";

%embed {:
    @Override
    protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
        super.recoverFromError(new Symbol(0), in);
    }
:};

%terminals VAR, FUNC, RETURN, IF, ELSE, WHILE, LCURLY, RCURLY, LPAREN, RPAREN, COMMA,
    ASSIGN, PLUS, MINUS, TIMES, DIV, AND, OR, OR, GT, LT, GEQ, LEQ, EQUAL, NEQ, NOT;
%terminals SEMICOLON, STMT_TAIL;
%terminals BOOL_LITERAL, NONE_LITERAL, NUMBER_LITERAL, ID, STRING_LITERAL;

%left PLUS, MINUS;
%left TIMES, DIV;
%left AND, OR;
%left EQUAL, NEQ;
%left GT, LT, GEQ, LEQ;
%right NOT;

%typeof expr = "IValue";

%goal module;

maybe_tail = stmt_tails
    |
    ;

stmt_tails = stmt_tails stmt_tail
    ;

stmt_tail = STMT_TAIL
    | SEMICOLON
    ;

module = functions
    ;

functions = functions maybe_tail function
    |   function
    ;

function = FUNC ID LPAREN parameters RPAREN block_statements
    |   FUNC ID LPAREN RPAREN block_statements
    ;

parameters = parameters COMMA ID COMMA
    |   ID
    ;

block_statements = LCURLY maybe_tail statements maybe_tail RCURLY
    |   LCURLY maybe_tail RCURLY
    ;

statements = statements stmt_tails statement
    |   statement
    ;

statement = var_statement
    |   assign_statement
    |   if_statement
    |   if_else_statement
    |   while_statement
    |   return_statement
    ;

var_statement = VAR var_declarations
    ;

var_declarations = var_declarations COMMA var_declaration
    |   var_declaration
    ;

var_declaration = ID
    |   assign_statement
    ;

assign_statement = ID ASSIGN expr
    ;

if_statement = IF assign_statement SEMICOLON expr block_statements
    |   IF expr block_statements
    ;

if_else_statement = if_statement ELSE block_statements
    ;

while_statement = WHILE assign_statement SEMICOLON expr block_statements
    |   WHILE expr block_statements
    ;

return_statement = RETURN
            {: return new Return(); :}
    |   RETURN expr.value
            {: return new Return(value); :}
    ;

expr = literal_expr.literal
            {: return literal;
            :}
    |   ID.id
            {: String value = (String) id.value;
               return new VarName(value);
            :}
    |   expr.left PLUS expr.right
            {:  return new AddExpr(left, right);
            :}
    |   expr.left MINUS expr.right
            {:  return new SubExpr(left, right);
            :}
    |   expr.left TIMES expr.right
            {:  return new MulExpr(left, right);
            :}
    |   expr.left DIV expr.right
            {:  return new DivExpr(left, right);
            :}
    |   expr.left AND expr.right
            {:  return new AndExpr(left, right);
            :}
    |   expr.left OR expr.right
            {:  return new OrExpr(left, right);
            :}
    |   expr.left EQUAL expr.right
            {:  return new EquExpr(left, right);
            :}
    |   expr.left NEQ expr.right
            {:  return new NotExpr(new EquExpr(left, right));
            :}
    |   expr.left GT expr.right
            {:  return new GreExpr(left, right);
            :}
    |   expr.left LT expr.right
            {:  return new LesExpr(left, right);
            :}
    |   expr.left GEQ expr.right
            {:  return new GeqExpr(left, right);
            :}
    |   expr.left LEQ expr.right
            {:  return new LeqExpr(left, right);
            :}
    |   NOT expr.left
            {:  return new NotExpr(left);
            :}
    |   LPAREN expr.left RPAREN
            {:  return (Node) left;
            :}
    ;

literal_expr = BOOL_LITERAL.bool
            {: if(bool.value.equals("true")) {
                   return new BooleanLiteral(true);
               } else {
                   return new BooleanLiteral(false);
               }
            :}
    |   NUMBER_LITERAL.number
            {: String value = (String) number.value;
               if(value.contains(".")) {
                   return new NumberLiteral(Double.parseDouble(value));
               } else {
                   return new NumberLiteral(Integer.parseInt(value));
               }
            :}
    |   STRING_LITERAL.string
            {: String value = (String) string.value;
               return new StringLiteral(value);
            :}
    |   NONE_LITERAL.none
            {: return new NoneLiteral();
            :}
    ;