package org.lucylang.ljvm.parser;

import org.lucylang.ljvm.node.*;
import org.apache.logging.log4j.Logger;
import java.io.IOException;
import beaver.*;
import org.apache.logging.log4j.LogManager;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "grammar.beaver".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short MINUS = 1;
		static public final short ID = 2;
		static public final short LPAREN = 3;
		static public final short STRING_LITERAL = 4;
		static public final short LSBRACKET = 5;
		static public final short NOT = 6;
		static public final short BOOL_LITERAL = 7;
		static public final short NUMBER_LITERAL = 8;
		static public final short NONE_LITERAL = 9;
		static public final short TIMES = 10;
		static public final short DIV = 11;
		static public final short PLUS = 12;
		static public final short GT = 13;
		static public final short LT = 14;
		static public final short GEQ = 15;
		static public final short LEQ = 16;
		static public final short STMT_TAIL = 17;
		static public final short SEMICOLON = 18;
		static public final short EQUAL = 19;
		static public final short NEQ = 20;
		static public final short AND = 21;
		static public final short OR = 22;
		static public final short RPAREN = 23;
		static public final short COMMA = 24;
		static public final short LCURLY = 25;
		static public final short FUNC = 26;
		static public final short RCURLY = 27;
		static public final short RSBRACKET = 28;
		static public final short DOUBLE_COLON = 29;
		static public final short PACKAGE = 30;
		static public final short IMPORT = 31;
		static public final short ASSIGN = 32;
		static public final short VAR = 33;
		static public final short IF = 34;
		static public final short WHILE = 35;
		static public final short RETURN = 36;
		static public final short ELSE = 37;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjLrjm5KKGFRit2OGO8mIuUO31c900kIH1224X2K8GHBWgYaz4G6CK5L50nHUOqW#r$5E" +
		"$rF97gz0FrB8K10LHV84Y8gA2uWFnXMzyHcdFpErTzkvTo$Z17pTrvlHqz$JqxFRCR02t4p" +
		"L8OXWcubGimcBaeXCZKOVXQC9uj682xIlGW4QCmcZCG16AG$QOY6#lmV6u59TZ8IwsqVfbn" +
		"EhZ#vf8VJFi#Rvz4R8Yx1s#VMX4BZLoC31#8FfdZ3ywO5#CMpBiVNrxk$o1#HdsOwmzYH7s" +
		"YHqLiiz6dhMVXaau1MVYB9oCcJW3io8qIIHiZFCZREqupgxkN7gTPxpaTvGourwOXsim6OD" +
		"GWZ8CGJdz1g0GsVoRpTnlG3NzUcCP1YFEN0xvzIIZ8vh3eQd1iTnJLRRUNFOgGpMJtgj2jZ" +
		"p3jtWrtwMfW9kntDzJMWl8yQKBSBRrChYGsbghpSCSeW1BS2CM44dKMtqI9oYFKHwhF4wvs" +
		"R8v4LfKCf6lr1nhM6KfAOasQ$Tw9$hZfcgaQMdswQezNVaYvSkKhr2#ohAPimFNsz5zSOdb" +
		"ap05KxYxZNmEAZ2NVM$brs8fhkF9SXDkXSDpeOhFRnZd7S6CNEhpk4$pkVCBk7iTler2dWi" +
		"3U3h46RrVoDx4$UFP7UwkSZxz2kwZLBHmh96#hubKd66F#NOpFjDUwzj7H#JY17A9dh$bF#" +
		"p5lZq6yEs5xGbhzvvO#5aDvkbXx0ujCPx6sQoyNZnTSYCqNenuX2r6grdT8DyBNBd9ECwAh" +
		"6CrDh0I6rc5GxdYyRGCvzpcR1z2ltgUnfNqAmduzIIZ8vh3eqbGvsgzETn$wJMJtZD#RNoB" +
		"fNoNfWBCk$Jsb5SBpO7wgxDU1dM#jeGPbB1IYdYJ9GXFtrDs0fA9dD0S7UQMaZnxUi$9Y9H" +
		"kxocREMjrRnLpdnisgodYITJ7tj6jjk#jF4xV19zN5l#0hXKmFxTHH7wcC09mjgPqM4jv6x" +
		"6Eyjsgkvzef$yqwdTGNfZIEmU9nobC9pQfRuxXCFXxcTWIRNEU81uYD8RpA9kVYCb4D#UTH" +
		"1tpTgUGyzLde78Pczl9rUHxoVN4AgA9U9hWMBStcJcw#UHPvFxaEUGApUqEOYNxupLc9nlw" +
		"EOkqlupFIK8vTz5$HiGwdwI#9T3lKF$Tn1SKDj3U7eXp5vk2K8nNgB#7NAa#3x0Pe$8ZR9Q" +
		"c#xjcRNDLRiZCoPsdd6IpNUNvWHpkvFBsKIYd$A3cy1YnclfTvDnGVatA2vHTuc5YOi1dJJ" +
		"YFm7otHUlTGJgssjEP#LMtHFa#ZR5UUREorg#ZwtDsAkjuPu$oNkK3ojsXjQqCvEDnbd9UH" +
		"Cu5OPt6NHMb3zYV2iKfZFPpu$JTg7BfeVpTieYO#mFZCkeWiCQPOJj$NV1$yhTjkRljwU1f" +
		"VpGQAtrBV2FTygTy9LyAgrfsoJxvNFRAPvG$9JwHFMm$9BOIRn9l45k8pSJhn6l4gmHhNNW" +
		"so2RY9TacRzaPFY3U9LwqlOtoWcmWhvVdvJbP9skjzbbP8plaVJ#$zsIdvTNoaNoikjssVK" +
		"Usozlob#oNh$b$9UHxuWVvJduLdZ9omAxq5#8tEa#rDr0DpAde4kP4Jw6DjrKRRwqcwfjvV" +
		"pHJDufoFULw#zsMGsJp#ob6c3ijcuZnsyF0uTV6lwE1SLhfrqfvjAAM$J74MFkjaqKOpY6o" +
		"UPF528VVBJ7xvJAEuwl8ASJ#9rnbRxpBEyO98KQul7coCE4VJRlyAG==");

    private final Logger logger = LogManager.getLogger(Parser.class.getName());

    public Module parseModule(beaver.Scanner source) throws IOException, Parser.Exception {
        return (Module) super.parse(source);
    }

    public Object parse(Scanner source, short alt_goal_marker_id) throws IOException, Parser.Exception {
        return (Module) super.parse(source, alt_goal_marker_id);
    }

    @Override
    protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
        super.recoverFromError(new Symbol(0), in);
    }

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] maybe_tail = stmt_tails
			Action.NONE,  	// [1] maybe_tail = 
			new Action() {	// [2] stmt_tails = stmt_tails stmt_tail
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [3] stmt_tails = stmt_tail
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [4] stmt_tail = STMT_TAIL
			Action.RETURN,	// [5] stmt_tail = SEMICOLON
			new Action() {	// [6] module = maybe_tail package.p stmt_tails imports.importList stmt_tails functions.fs maybe_tail
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 2];
					final org.lucylang.ljvm.node.Package p = (org.lucylang.ljvm.node.Package) _symbol_p.value;
					final Symbol _symbol_importList = _symbols[offset + 4];
					final SymbolList importList = (SymbolList) _symbol_importList.value;
					final Symbol _symbol_fs = _symbols[offset + 6];
					final SymbolList fs = (SymbolList) _symbol_fs.value;
					 Module module = new Module(p.getPackageName());
               for(int i=0; i<importList.size(); i++) {
                   module.addImport(((Import) importList.get(i)).getModuleName());
               }
               for(int i=0; i<fs.size(); i++) {
                   module.addFunction((Function) fs.get(i));
               }
               return module;
				}
			},
			new Action() {	// [7] module = maybe_tail package.p stmt_tails functions.fs maybe_tail
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 2];
					final org.lucylang.ljvm.node.Package p = (org.lucylang.ljvm.node.Package) _symbol_p.value;
					final Symbol _symbol_fs = _symbols[offset + 4];
					final SymbolList fs = (SymbolList) _symbol_fs.value;
					 Module module = new Module(p.getPackageName());
               for(int i=0; i<fs.size(); i++) {
                   module.addFunction((Function) fs.get(i));
               }
               return module;
				}
			},
			new Action() {	// [8] package = PACKAGE STRING_LITERAL.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol value = _symbols[offset + 2];
					 return new org.lucylang.ljvm.node.Package((String) value.value);
				}
			},
			new Action() {	// [9] imports = imports.importList stmt_tails import.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_importList = _symbols[offset + 1];
					final SymbolList importList = (SymbolList) _symbol_importList.value;
					final Symbol i = _symbols[offset + 3];
					 importList.add(i);
               return importList;
				}
			},
			new Action() {	// [10] imports = import.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol i = _symbols[offset + 1];
					 SymbolList list = new SymbolList();
               list.add(i);
               return list;
				}
			},
			new Action() {	// [11] import = IMPORT STRING_LITERAL.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol value = _symbols[offset + 2];
					 return new Import((String) value.value);
				}
			},
			new Action() {	// [12] functions = functions.fs maybe_tail function.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_fs = _symbols[offset + 1];
					final SymbolList fs = (SymbolList) _symbol_fs.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Function f = (Function) _symbol_f.value;
					 fs.add(f);
               return fs;
				}
			},
			new Action() {	// [13] functions = function.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final Function f = (Function) _symbol_f.value;
					 SymbolList list = new SymbolList();
               list.add(f);
               return list;
				}
			},
			new Action() {	// [14] function = FUNC ID.name LPAREN parameters.list RPAREN block_statements.stmts
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol name = _symbols[offset + 2];
					final Symbol _symbol_list = _symbols[offset + 4];
					final SymbolList list = (SymbolList) _symbol_list.value;
					final Symbol _symbol_stmts = _symbols[offset + 6];
					final SymbolList stmts = (SymbolList) _symbol_stmts.value;
					 Function function = new Function((String) name.value);
               logger.trace("Function " + name.value + " parameters size: " + list.size());
               for(int i=0; i<list.size(); i++) {
                   logger.trace(list.get(i));
                   function.addParameter((VarName) list.get(i));
               }
               for(int i=0; i<stmts.size(); i++) {
                   function.addStmt((IStmt)stmts.get(i));
               }
               return function;
				}
			},
			new Action() {	// [15] function = FUNC ID.name LPAREN RPAREN block_statements.stmts
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol name = _symbols[offset + 2];
					final Symbol _symbol_stmts = _symbols[offset + 5];
					final SymbolList stmts = (SymbolList) _symbol_stmts.value;
					 Function function = new Function((String) name.value);
               logger.trace("Function " + name.value + " parameters size: 0");
               for(int i=0; i<stmts.size(); i++) {
                   function.addStmt((IStmt)stmts.get(i));
               }
               return function;
				}
			},
			new Action() {	// [16] parameters = parameters.list COMMA ID.varName
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final SymbolList list = (SymbolList) _symbol_list.value;
					final Symbol varName = _symbols[offset + 3];
					 list.add(new VarName((String) varName.value));
               return list;
				}
			},
			new Action() {	// [17] parameters = ID.varName
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol varName = _symbols[offset + 1];
					 SymbolList list = new SymbolList();
               list.add(new VarName((String) varName.value));
               return list;
				}
			},
			new Action() {	// [18] block_statements = LCURLY maybe_tail statements.stmts maybe_tail RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stmts = _symbols[offset + 3];
					final SymbolList stmts = (SymbolList) _symbol_stmts.value;
					 return stmts;
				}
			},
			new Action() {	// [19] block_statements = LCURLY maybe_tail RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new SymbolList();
				}
			},
			new Action() {	// [20] statements = statements.stmts stmt_tails statement.stmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stmts = _symbols[offset + 1];
					final SymbolList stmts = (SymbolList) _symbol_stmts.value;
					final Symbol stmt = _symbols[offset + 3];
					 if(stmt instanceof SymbolList) {
                   SymbolList list = (SymbolList) stmt;
                   for(int i=0; i<list.size(); i++) {
                       stmts.add(list.get(i));
                   }
               } else {
                   stmts.add(stmt);
               }
               return stmts;
				}
			},
			new Action() {	// [21] statements = statement.stmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stmt = _symbols[offset + 1];
					 if(stmt instanceof SymbolList) {
                   return stmt;
               } else {
                   SymbolList list = new SymbolList();
                   list.add(stmt);
                   return list;
               }
				}
			},
			new Action() {	// [22] statement = var_statement.var
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol var = _symbols[offset + 1];
					 return var;
				}
			},
			new Action() {	// [23] statement = assign_statement.assign
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_assign = _symbols[offset + 1];
					final Assignment assign = (Assignment) _symbol_assign.value;
					 return assign;
				}
			},
			new Action() {	// [24] statement = if_statement.ifStmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ifStmt = _symbols[offset + 1];
					final IfElse ifStmt = (IfElse) _symbol_ifStmt.value;
					 return ifStmt;
				}
			},
			new Action() {	// [25] statement = if_else_statement.ifStmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ifStmt = _symbols[offset + 1];
					final IfElse ifStmt = (IfElse) _symbol_ifStmt.value;
					 return ifStmt;
				}
			},
			new Action() {	// [26] statement = while_statement.whileStmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_whileStmt = _symbols[offset + 1];
					final While whileStmt = (While) _symbol_whileStmt.value;
					 return whileStmt;
				}
			},
			new Action() {	// [27] statement = call_statement.call
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_call = _symbols[offset + 1];
					final Call call = (Call) _symbol_call.value;
					 return call;
				}
			},
			new Action() {	// [28] statement = return_statement.returnStmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_returnStmt = _symbols[offset + 1];
					final Return returnStmt = (Return) _symbol_returnStmt.value;
					 return returnStmt;
				}
			},
			new Action() {	// [29] var_statement = VAR var_declarations.declarations
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_declarations = _symbols[offset + 2];
					final SymbolList declarations = (SymbolList) _symbol_declarations.value;
					 return declarations;
				}
			},
			new Action() {	// [30] var_declarations = var_declarations.declarations COMMA var_declaration.var
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_declarations = _symbols[offset + 1];
					final SymbolList declarations = (SymbolList) _symbol_declarations.value;
					final Symbol var = _symbols[offset + 3];
					 declarations.add(var);
               return declarations;
				}
			},
			new Action() {	// [31] var_declarations = var_declaration.var
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol var = _symbols[offset + 1];
					 SymbolList list = new SymbolList();
               list.add(var);
               return list;
				}
			},
			new Action() {	// [32] var_declaration = ID.varName
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol varName = _symbols[offset + 1];
					 return new Assignment(new VarName((String) varName.value), new NoneLiteral());
				}
			},
			new Action() {	// [33] var_declaration = assign_statement.assignment
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_assignment = _symbols[offset + 1];
					final Assignment assignment = (Assignment) _symbol_assignment.value;
					 return assignment;
				}
			},
			new Action() {	// [34] assign_statement = ID.varName ASSIGN expr.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol varName = _symbols[offset + 1];
					final Symbol _symbol_value = _symbols[offset + 3];
					final IValue value = (IValue) _symbol_value.value;
					 return new Assignment(new VarName((String) varName.value), value);
				}
			},
			new Action() {	// [35] if_statement = IF expr.value block_statements.statements
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_value = _symbols[offset + 2];
					final IValue value = (IValue) _symbol_value.value;
					final Symbol _symbol_statements = _symbols[offset + 3];
					final SymbolList statements = (SymbolList) _symbol_statements.value;
					 IfElse ifElse = new IfElse(value);
               for(int i=0; i<statements.size(); i++)
                   ifElse.addStmtIf((IStmt) statements.get(i));
               return ifElse;
				}
			},
			new Action() {	// [36] if_else_statement = if_statement.ifElse ELSE block_statements.statements
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ifElse = _symbols[offset + 1];
					final IfElse ifElse = (IfElse) _symbol_ifElse.value;
					final Symbol _symbol_statements = _symbols[offset + 3];
					final SymbolList statements = (SymbolList) _symbol_statements.value;
					 for(int i=0; i<statements.size(); i++)
                   ifElse.addStmtElse((IStmt) statements.get(i));
               return ifElse;
				}
			},
			new Action() {	// [37] call_statement = ID.name LPAREN exprs.list RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol name = _symbols[offset + 1];
					final Symbol _symbol_list = _symbols[offset + 3];
					final SymbolList list = (SymbolList) _symbol_list.value;
					 Call call = new Call(new VarName((String) name.value));
               for(int i=0; i<list.size(); i++) {
                   call.addParameter((IValue) list.get(i));
               }
               return call;
				}
			},
			new Action() {	// [38] call_statement = ID.name LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol name = _symbols[offset + 1];
					  return new Call(new VarName((String) name.value));
				}
			},
			new Action() {	// [39] call_statement = ID.module DOUBLE_COLON ID.name LPAREN exprs.list RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol module = _symbols[offset + 1];
					final Symbol name = _symbols[offset + 3];
					final Symbol _symbol_list = _symbols[offset + 5];
					final SymbolList list = (SymbolList) _symbol_list.value;
					 Call call = new Call(new VarName((String) module.value + "::" + (String) name.value));
               for(int i=0; i<list.size(); i++) {
                   call.addParameter((IValue) list.get(i));
               }
               return call;
				}
			},
			new Action() {	// [40] call_statement = ID.module DOUBLE_COLON ID.name LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol module = _symbols[offset + 1];
					final Symbol name = _symbols[offset + 3];
					  return new Call(new VarName((String) module.value + "::" + (String) name.value));
				}
			},
			new Action() {	// [41] exprs = exprs.list COMMA expr.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final SymbolList list = (SymbolList) _symbol_list.value;
					final Symbol _symbol_value = _symbols[offset + 3];
					final IValue value = (IValue) _symbol_value.value;
					 list.add((Node) value);
               return list;
				}
			},
			new Action() {	// [42] exprs = expr.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_value = _symbols[offset + 1];
					final IValue value = (IValue) _symbol_value.value;
					 SymbolList list = new SymbolList();
               list.add((Node) value);
               return list;
				}
			},
			new Action() {	// [43] while_statement = WHILE expr.value block_statements.statements
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_value = _symbols[offset + 2];
					final IValue value = (IValue) _symbol_value.value;
					final Symbol _symbol_statements = _symbols[offset + 3];
					final SymbolList statements = (SymbolList) _symbol_statements.value;
					 While whileStmt = new While(value);
               for(int i=0; i<statements.size(); i++)
                   whileStmt.addStmt((IStmt) statements.get(i));
               return whileStmt;
				}
			},
			new Action() {	// [44] return_statement = RETURN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Return();
				}
			},
			new Action() {	// [45] return_statement = RETURN expr.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_value = _symbols[offset + 2];
					final IValue value = (IValue) _symbol_value.value;
					 return new Return(value);
				}
			},
			new Action() {	// [46] expr = literal_expr.literal
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol literal = _symbols[offset + 1];
					 return literal;
				}
			},
			new Action() {	// [47] expr = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 String value = (String) id.value;
               return new VarName(value);
				}
			},
			new Action() {	// [48] expr = expr.left PLUS expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new AddExpr(left, right);
				}
			},
			new Action() {	// [49] expr = expr.left MINUS expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new SubExpr(left, right);
				}
			},
			new Action() {	// [50] expr = expr.left TIMES expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new MulExpr(left, right);
				}
			},
			new Action() {	// [51] expr = expr.left DIV expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new DivExpr(left, right);
				}
			},
			new Action() {	// [52] expr = expr.left AND expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new AndExpr(left, right);
				}
			},
			new Action() {	// [53] expr = expr.left OR expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new OrExpr(left, right);
				}
			},
			new Action() {	// [54] expr = expr.left EQUAL expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new EquExpr(left, right);
				}
			},
			new Action() {	// [55] expr = expr.left NEQ expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new NotExpr(new EquExpr(left, right));
				}
			},
			new Action() {	// [56] expr = expr.left GT expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new GreExpr(left, right);
				}
			},
			new Action() {	// [57] expr = expr.left LT expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new LesExpr(left, right);
				}
			},
			new Action() {	// [58] expr = expr.left GEQ expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new GeqExpr(left, right);
				}
			},
			new Action() {	// [59] expr = expr.left LEQ expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new LeqExpr(left, right);
				}
			},
			new Action() {	// [60] expr = NOT expr.left
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 2];
					final IValue left = (IValue) _symbol_left.value;
					  return new NotExpr(left);
				}
			},
			new Action() {	// [61] expr = LPAREN expr.left RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 2];
					final IValue left = (IValue) _symbol_left.value;
					  return (Node) left;
				}
			},
			new Action() {	// [62] expr = call_statement.call
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_call = _symbols[offset + 1];
					final Call call = (Call) _symbol_call.value;
					  return (Node) call;
				}
			},
			new Action() {	// [63] expr = array_value_at.valueAt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_valueAt = _symbols[offset + 1];
					final ValueAt valueAt = (ValueAt) _symbol_valueAt.value;
					  return (Node) valueAt;
				}
			},
			new Action() {	// [64] expr = MINUS expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_right = _symbols[offset + 2];
					final IValue right = (IValue) _symbol_right.value;
					  return new SubExpr(new NumberLiteral(0), right);
				}
			},
			new Action() {	// [65] literal_expr = BOOL_LITERAL.bool
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol bool = _symbols[offset + 1];
					 if(bool.value.equals("true")) {
                   return new BooleanLiteral(true);
               } else {
                   return new BooleanLiteral(false);
               }
				}
			},
			new Action() {	// [66] literal_expr = NUMBER_LITERAL.number
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol number = _symbols[offset + 1];
					 String value = (String) number.value;
               if(value.contains(".")) {
                   return new NumberLiteral(Double.parseDouble(value));
               } else {
                   return new NumberLiteral(Integer.parseInt(value));
               }
				}
			},
			new Action() {	// [67] literal_expr = STRING_LITERAL.string
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol string = _symbols[offset + 1];
					 String value = (String) string.value;
               return new StringLiteral(value);
				}
			},
			new Action() {	// [68] literal_expr = NONE_LITERAL.none
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol none = _symbols[offset + 1];
					 return new NoneLiteral();
				}
			},
			new Action() {	// [69] literal_expr = LSBRACKET exprs.es RSBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_es = _symbols[offset + 2];
					final SymbolList es = (SymbolList) _symbol_es.value;
					 ArrayLiteral array = new ArrayLiteral(es.size());
               for(int i=0; i<es.size(); i++) {
                   array.setValue(i, (IValue) es.get(i));
               }
               return array;
				}
			},
			new Action() {	// [70] literal_expr = LSBRACKET RSBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new ArrayLiteral(0);
				}
			},
			new Action() {	// [71] array_value_at = ID.name LSBRACKET expr.e RSBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol name = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final IValue e = (IValue) _symbol_e.value;
					  return new ValueAt(new VarName((String) name.value), e);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
