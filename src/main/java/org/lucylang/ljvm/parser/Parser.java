package org.lucylang.ljvm.parser;

import org.lucylang.ljvm.node.*;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "grammar.beaver".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short LPAREN = 2;
		static public final short NOT = 3;
		static public final short BOOL_LITERAL = 4;
		static public final short NUMBER_LITERAL = 5;
		static public final short STRING_LITERAL = 6;
		static public final short NONE_LITERAL = 7;
		static public final short RCURLY = 8;
		static public final short PLUS = 9;
		static public final short MINUS = 10;
		static public final short TIMES = 11;
		static public final short DIV = 12;
		static public final short AND = 13;
		static public final short OR = 14;
		static public final short EQUAL = 15;
		static public final short NEQ = 16;
		static public final short GT = 17;
		static public final short LT = 18;
		static public final short GEQ = 19;
		static public final short LEQ = 20;
		static public final short LCURLY = 21;
		static public final short SEMICOLON = 22;
		static public final short FUNC = 23;
		static public final short RPAREN = 24;
		static public final short COMMA = 25;
		static public final short ASSIGN = 26;
		static public final short IF = 27;
		static public final short WHILE = 28;
		static public final short STMT_TAIL = 29;
		static public final short VAR = 30;
		static public final short RETURN = 31;
		static public final short ELSE = 32;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pbbLjiL5KKXl$JMZiYKB3jOAkLbXaixT3R39LRkLWeK0j2AGY820Xe32769nvCZ18ra80" +
		"eKJ3HH4FWZVWYRxxv17ZZwbsy8gWeU4NmilpEwUxqJ3lLZE49pybt$hNsMhFsdhFNx96yLn" +
		"JNpHgZMerLlHgLr3ZTeWcQf7ojq5Lg7J1#xUMDsCS3nd8TZ#eQtMrVwowrgq0ZLAfotQ0Rp" +
		"JI4s62#Lu6kqt2Dx8sf95tjDYrKiIgqh5$zNFqfcgwfcg6PQjCiEvdfNn5Uvt#CjTkbzDkw" +
		"MiiLoNXt8Tk#qrgjiRzK6EpBx61VyZHKmpJ73cY#MkYf3WtI4goRrANhjPgi6DvejV2vIbL" +
		"Zru1VDU6q3cs09aX1Cuo7YJ0Pfi6jC0yMmvrGeYBxmSxPzynOfcBxpCxQj$QDghX7ST#k1J" +
		"pdQf7ki4#rr3wny$JOIh9NwHuwSX3MO3fmg8fO$N0wi9YQerbDDQiUA5vwcIEH0MEvZiTPT" +
		"HdrniZZTvHWj#hOkmP6ceZvtsi4iHfoUcFHT3N$DrV1ZetiLpzNtwCVyZcf2kYaGcRFzF$V" +
		"dj9lo#FD93FUNTYEq8F#BkO5#n8FzgKnsCDQJbM$lqiPZGLM2gkIlOy7da#4h1xRhnhMN8b" +
		"IhVikPRwAjETnbtF7kCl9YgAHW0Wzvf5TXYUjUqJ1jLJo9gDhkdrl6dJ20fo5Q8S$xc8JuL" +
		"xOvZwxmOq$6ShP3a$1R7WCde5dOIViWXT9Mek#vF8tyzWFS#1LL$SrfmU9hqSFem#Wxy93S" +
		"18$XPv29w5dqUdeJy2SkWHR6VFtrPy$WhuGMcCHZqLerCmkz8ndWvmjK05FGvo1GhUs4XVt" +
		"vqd03aWoK8NkHklHFUW#Q76vU#5XU1cUSsFFPvcpXdMTzkapFgndZzmQkg0DlxatHrt$ydq" +
		"sPXbBEcqBZRKxxN0wtscdqyLEbpbTxdI5qvLELpljwI$NTzvzVTPmlzFr$xJ#KFuKfnlWKM" +
		"Tl2iLRdT8ttXFEtkpqmJwr7k$ZRy$qjKxkiejANtQ1VyrkYxwpF#4F#rrPBpjZN$7y4Zw0z" +
		"#4ze9$j7JW1n#4O78KZGC$Rs$QHVOY#5THuqzwmr#sG7RHJTZfK#mlutC$hD#kFO87r2$ng" +
		"FzjlEECvhpmGfrPUS2RuZ8D6piH6j9fJiPgpCSa9cSIFOSU8DGLumJzPDiPIBqLE2hlM4ST" +
		"FyFa4MWVrsFLe0x46yglGRl9p92$GKNmsJFFVKenKBm==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

    @Override
    protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
        super.recoverFromError(new Symbol(0), in);
    }

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] maybe_tail = stmt_tails
			Action.NONE,  	// [1] maybe_tail = 
			RETURN2,	// [2] stmt_tails = stmt_tails stmt_tail; returns 'stmt_tail' although none is marked
			Action.RETURN,	// [3] stmt_tail = STMT_TAIL
			Action.RETURN,	// [4] stmt_tail = SEMICOLON
			Action.RETURN,	// [5] module = functions
			new Action() {	// [6] functions = functions maybe_tail function
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [7] functions = function
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN6,	// [8] function = FUNC ID LPAREN parameters RPAREN block_statements; returns 'block_statements' although none is marked
			RETURN5,	// [9] function = FUNC ID LPAREN RPAREN block_statements; returns 'block_statements' although none is marked
			RETURN4,	// [10] parameters = parameters COMMA ID COMMA; returns 'COMMA' although none is marked
			Action.RETURN,	// [11] parameters = ID
			RETURN5,	// [12] block_statements = LCURLY maybe_tail statements maybe_tail RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [13] block_statements = LCURLY maybe_tail RCURLY; returns 'RCURLY' although none is marked
			new Action() {	// [14] statements = statements stmt_tails statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [15] statements = statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [16] statement = var_statement
			Action.RETURN,	// [17] statement = assign_statement
			Action.RETURN,	// [18] statement = if_statement
			Action.RETURN,	// [19] statement = if_else_statement
			Action.RETURN,	// [20] statement = while_statement
			Action.RETURN,	// [21] statement = return_statement
			RETURN2,	// [22] var_statement = VAR var_declarations; returns 'var_declarations' although none is marked
			new Action() {	// [23] var_declarations = var_declarations COMMA var_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [24] var_declarations = var_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [25] var_declaration = ID
			Action.RETURN,	// [26] var_declaration = assign_statement
			RETURN3,	// [27] assign_statement = ID ASSIGN expr; returns 'expr' although none is marked
			RETURN5,	// [28] if_statement = IF assign_statement SEMICOLON expr block_statements; returns 'block_statements' although none is marked
			RETURN3,	// [29] if_statement = IF expr block_statements; returns 'block_statements' although none is marked
			RETURN3,	// [30] if_else_statement = if_statement ELSE block_statements; returns 'block_statements' although none is marked
			RETURN5,	// [31] while_statement = WHILE assign_statement SEMICOLON expr block_statements; returns 'block_statements' although none is marked
			RETURN3,	// [32] while_statement = WHILE expr block_statements; returns 'block_statements' although none is marked
			new Action() {	// [33] return_statement = RETURN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Return();
				}
			},
			new Action() {	// [34] return_statement = RETURN expr.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_value = _symbols[offset + 2];
					final IValue value = (IValue) _symbol_value.value;
					 return new Return(value);
				}
			},
			new Action() {	// [35] expr = literal_expr.literal
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol literal = _symbols[offset + 1];
					 return literal;
				}
			},
			new Action() {	// [36] expr = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 String value = (String) id.value;
               return new VarName(value);
				}
			},
			new Action() {	// [37] expr = expr.left PLUS expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new AddExpr(left, right);
				}
			},
			new Action() {	// [38] expr = expr.left MINUS expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new SubExpr(left, right);
				}
			},
			new Action() {	// [39] expr = expr.left TIMES expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new MulExpr(left, right);
				}
			},
			new Action() {	// [40] expr = expr.left DIV expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new DivExpr(left, right);
				}
			},
			new Action() {	// [41] expr = expr.left AND expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new AndExpr(left, right);
				}
			},
			new Action() {	// [42] expr = expr.left OR expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new OrExpr(left, right);
				}
			},
			new Action() {	// [43] expr = expr.left EQUAL expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new EquExpr(left, right);
				}
			},
			new Action() {	// [44] expr = expr.left NEQ expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new NotExpr(new EquExpr(left, right));
				}
			},
			new Action() {	// [45] expr = expr.left GT expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new GreExpr(left, right);
				}
			},
			new Action() {	// [46] expr = expr.left LT expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new LesExpr(left, right);
				}
			},
			new Action() {	// [47] expr = expr.left GEQ expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new GeqExpr(left, right);
				}
			},
			new Action() {	// [48] expr = expr.left LEQ expr.right
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 1];
					final IValue left = (IValue) _symbol_left.value;
					final Symbol _symbol_right = _symbols[offset + 3];
					final IValue right = (IValue) _symbol_right.value;
					  return new LeqExpr(left, right);
				}
			},
			new Action() {	// [49] expr = NOT expr.left
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 2];
					final IValue left = (IValue) _symbol_left.value;
					  return new NotExpr(left);
				}
			},
			new Action() {	// [50] expr = LPAREN expr.left RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_left = _symbols[offset + 2];
					final IValue left = (IValue) _symbol_left.value;
					  return (Node) left;
				}
			},
			new Action() {	// [51] literal_expr = BOOL_LITERAL.bool
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol bool = _symbols[offset + 1];
					 if(bool.value.equals("true")) {
                   return new BooleanLiteral(true);
               } else {
                   return new BooleanLiteral(false);
               }
				}
			},
			new Action() {	// [52] literal_expr = NUMBER_LITERAL.number
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol number = _symbols[offset + 1];
					 String value = (String) number.value;
               if(value.contains(".")) {
                   return new NumberLiteral(Double.parseDouble(value));
               } else {
                   return new NumberLiteral(Integer.parseInt(value));
               }
				}
			},
			new Action() {	// [53] literal_expr = STRING_LITERAL.string
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol string = _symbols[offset + 1];
					 String value = (String) string.value;
               return new StringLiteral(value);
				}
			},
			new Action() {	// [54] literal_expr = NONE_LITERAL.none
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol none = _symbols[offset + 1];
					 return new NoneLiteral();
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
